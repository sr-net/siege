// GENERATED by @edgedb/generate v0.0.7-beta.2
// Run 'npx @edgedb/generate interfaces' to re-generate

import type * as edgedb from "edgedb"

export namespace std {
  export type BaseObject = {
    id: string
  }

  export type $Object = {} & BaseObject

  export type FreeObject = {} & BaseObject

  export type JsonEmpty =
    | "ReturnEmpty"
    | "ReturnTarget"
    | "Error"
    | "UseNull"
    | "DeleteKey"
}
export namespace cfg {
  export type ConfigObject = {} & std.BaseObject

  export type AbstractConfig = {
    session_idle_timeout: edgedb.Duration
    session_idle_transaction_timeout: edgedb.Duration
    query_execution_timeout: edgedb.Duration
    listen_port: number
    listen_addresses: string[]
    allow_dml_in_functions?: boolean | null
    allow_bare_ddl?: AllowBareDDL | null
    apply_access_policies?: boolean | null
    allow_user_specified_id?: boolean | null
    shared_buffers?: edgedb.ConfigMemory | null
    query_work_mem?: edgedb.ConfigMemory | null
    effective_cache_size?: edgedb.ConfigMemory | null
    effective_io_concurrency?: number | null
    default_statistics_target?: number | null
    auth: Auth[]
  } & ConfigObject

  export type AllowBareDDL = "AlwaysAllow" | "NeverAllow"

  export type Auth = {
    priority: number
    user: string[]
    comment?: string | null
    method?: AuthMethod | null
  } & ConfigObject

  export type AuthMethod = {
    transports: ConnectionTransport[]
  } & ConfigObject

  export type Config = {} & AbstractConfig

  export type ConnectionTransport = "TCP" | "HTTP"

  export type DatabaseConfig = {} & AbstractConfig

  export type InstanceConfig = {} & AbstractConfig

  export type JWT = {
    transports: ConnectionTransport[]
  } & AuthMethod

  export type SCRAM = {
    transports: ConnectionTransport[]
  } & AuthMethod

  export type Trust = {} & AuthMethod
}

export type EnhancedObject = {
  createdAt: Date
} & std.$Object

export type Author = {
  name: string
  kind: AuthorKind
  url?: string | null
  strats: Strat[]
} & EnhancedObject

export type AuthorKind = "NAME" | "YOUTUBE" | "TWITCH" | "REDDIT"
export type Gamemode = "BOMBS" | "HOSTAGE" | "CAPTURE_AREAS"

export type Like = {
  sessionId: string
  active?: boolean | null
  strat: Strat
} & EnhancedObject

export type Report = {
  sessionId: string
  message?: string | null
  strat: Strat
} & EnhancedObject

export type Strat = {
  def: boolean
  gamemodes: Gamemode[]
  atk: boolean
  submission: boolean
  acceptedAt?: Date | null
  description: string
  score: number
  shortId: number
  title: string
  author: Author
  likes: Like[]
  reports: Report[]
} & EnhancedObject

export namespace schema {
  export type AccessKind = "Select" | "UpdateRead" | "UpdateWrite" | "Delete" | "Insert"

  export type $Object = {
    name: string
    internal: boolean
    builtin: boolean
    computed_fields?: string[] | null
  } & std.BaseObject

  export type SubclassableObject = {
    abstract?: boolean | null
    is_abstract?: boolean | null
    final: boolean
    is_final: boolean
  } & $Object

  export type InheritingObject = {
    inherited_fields?: string[] | null
    bases: InheritingObject[]
    ancestors: InheritingObject[]
  } & SubclassableObject

  export type AnnotationSubject = {
    annotations: Annotation[]
  } & $Object

  export type AccessPolicy = {
    access_kinds: AccessKind[]
    condition?: string | null
    action: AccessPolicyAction
    expr?: string | null
    subject: ObjectType
  } & InheritingObject &
    AnnotationSubject

  export type AccessPolicyAction = "Allow" | "Deny"

  export type Alias = {
    expr: string
    type: Type
  } & AnnotationSubject

  export type Annotation = {
    inheritable?: boolean | null
  } & InheritingObject &
    AnnotationSubject

  export type Type = {
    expr?: string | null
    from_alias?: boolean | null
    is_from_alias?: boolean | null
  } & SubclassableObject &
    AnnotationSubject

  export type PrimitiveType = {} & Type

  export type CollectionType = {} & PrimitiveType

  export type Array = {
    dimensions?: number[] | null
    element_type: Type
  } & CollectionType

  export type CallableObject = {
    return_typemod?: TypeModifier | null
    params: Parameter[]
    return_type?: Type | null
  } & AnnotationSubject

  export type Cardinality = "One" | "Many"

  export type VolatilitySubject = {
    volatility?: Volatility | null
  } & $Object

  export type Cast = {
    allow_implicit?: boolean | null
    allow_assignment?: boolean | null
    from_type?: Type | null
    to_type?: Type | null
  } & AnnotationSubject &
    VolatilitySubject

  export type ConsistencySubject = {
    constraints: Constraint[]
  } & $Object &
    InheritingObject &
    AnnotationSubject

  export type Constraint = {
    expr?: string | null
    subjectexpr?: string | null
    finalexpr?: string | null
    errmessage?: string | null
    delegated?: boolean | null
    except_expr?: string | null
    subject?: ConsistencySubject | null
    params: Parameter[]
  } & CallableObject &
    InheritingObject

  export type Delta = {
    parents: Delta[]
  } & $Object

  export type Extension = {
    package: sys.ExtensionPackage
  } & AnnotationSubject &
    $Object

  export type Function = {
    body?: string | null
    language: string
    preserves_optionality?: boolean | null
    used_globals: Global[]
  } & CallableObject &
    VolatilitySubject

  export type FutureBehavior = {} & $Object

  export type Global = {
    required?: boolean | null
    cardinality?: Cardinality | null
    expr?: string | null
    default?: string | null
    target: Type
  } & AnnotationSubject

  export type Index = {
    expr?: string | null
    except_expr?: string | null
  } & InheritingObject &
    AnnotationSubject

  export type Pointer = {
    cardinality?: Cardinality | null
    required?: boolean | null
    readonly?: boolean | null
    default?: string | null
    expr?: string | null
    source?: Source | null
    target?: Type | null
  } & InheritingObject &
    ConsistencySubject &
    AnnotationSubject

  export type Source = {
    pointers: Pointer[]
    indexes: Index[]
  } & $Object

  export type Link = {
    on_target_delete?: TargetDeleteAction | null
    on_source_delete?: SourceDeleteAction | null
    target?: ObjectType | null
    properties: Property[]
  } & Pointer &
    Source

  export type Migration = {
    script: string
    message?: string | null
    parents: Migration[]
  } & AnnotationSubject &
    $Object

  export type Module = {} & $Object & AnnotationSubject

  export type ObjectType = {
    compound_type: boolean
    is_compound_type: boolean
    union_of: ObjectType[]
    intersection_of: ObjectType[]
    properties: Property[]
    links: Link[]
    access_policies: AccessPolicy[]
  } & InheritingObject &
    ConsistencySubject &
    AnnotationSubject &
    Type &
    Source

  export type Operator = {
    operator_kind?: OperatorKind | null
    is_abstract?: boolean | null
    abstract?: boolean | null
  } & CallableObject &
    VolatilitySubject

  export type OperatorKind = "Infix" | "Postfix" | "Prefix" | "Ternary"

  export type Parameter = {
    typemod: TypeModifier
    kind: ParameterKind
    num: number
    default?: string | null
    type: Type
  } & $Object

  export type ParameterKind = "VariadicParam" | "NamedOnlyParam" | "PositionalParam"

  export type Property = {} & Pointer

  export type PseudoType = {} & InheritingObject & Type

  export type Range = {
    element_type: Type
  } & CollectionType

  export type ScalarType = {
    default?: string | null
    enum_values?: string[] | null
  } & InheritingObject &
    ConsistencySubject &
    AnnotationSubject &
    PrimitiveType

  export type SourceDeleteAction = "DeleteTarget" | "Allow" | "DeleteTargetIfOrphan"
  export type TargetDeleteAction =
    | "Restrict"
    | "DeleteSource"
    | "Allow"
    | "DeferredRestrict"

  export type Tuple = {
    named: boolean
    element_types: TupleElement[]
  } & CollectionType

  export type TupleElement = {
    name?: string | null
    type: Type
  } & std.BaseObject

  export type TypeModifier = "SetOfType" | "OptionalType" | "SingletonType"
  export type Volatility = "Immutable" | "Stable" | "Volatile"
}
export namespace sys {
  export type SystemObject = {} & schema.AnnotationSubject

  export type Database = {
    name: string
  } & SystemObject &
    schema.AnnotationSubject

  export type ExtensionPackage = {
    script: string
    version: {
      major: number
      minor: number
      stage: VersionStage
      stage_no: number
      local: string[]
    }
  } & SystemObject &
    schema.AnnotationSubject

  export type Role = {
    superuser: boolean
    password?: string | null
    name: string
    is_superuser: boolean
    member_of: Role[]
  } & SystemObject &
    schema.InheritingObject &
    schema.AnnotationSubject

  export type TransactionIsolation = "RepeatableRead" | "Serializable"
  export type VersionStage = "dev" | "alpha" | "beta" | "rc" | "final"
}

export type types = {
  std: {
    BaseObject: std.BaseObject
    Object: std.$Object
    FreeObject: std.FreeObject
    JsonEmpty: std.JsonEmpty
  }
  cfg: {
    ConfigObject: cfg.ConfigObject
    AbstractConfig: cfg.AbstractConfig
    AllowBareDDL: cfg.AllowBareDDL
    Auth: cfg.Auth
    AuthMethod: cfg.AuthMethod
    Config: cfg.Config
    ConnectionTransport: cfg.ConnectionTransport
    DatabaseConfig: cfg.DatabaseConfig
    InstanceConfig: cfg.InstanceConfig
    JWT: cfg.JWT
    SCRAM: cfg.SCRAM
    Trust: cfg.Trust
  }
  default: {
    EnhancedObject: EnhancedObject
    Author: Author
    AuthorKind: AuthorKind
    Gamemode: Gamemode
    Like: Like
    Report: Report
    Strat: Strat
  }
  schema: {
    AccessKind: schema.AccessKind
    Object: schema.$Object
    SubclassableObject: schema.SubclassableObject
    InheritingObject: schema.InheritingObject
    AnnotationSubject: schema.AnnotationSubject
    AccessPolicy: schema.AccessPolicy
    AccessPolicyAction: schema.AccessPolicyAction
    Alias: schema.Alias
    Annotation: schema.Annotation
    Type: schema.Type
    PrimitiveType: schema.PrimitiveType
    CollectionType: schema.CollectionType
    Array: schema.Array
    CallableObject: schema.CallableObject
    Cardinality: schema.Cardinality
    VolatilitySubject: schema.VolatilitySubject
    Cast: schema.Cast
    ConsistencySubject: schema.ConsistencySubject
    Constraint: schema.Constraint
    Delta: schema.Delta
    Extension: schema.Extension
    Function: schema.Function
    FutureBehavior: schema.FutureBehavior
    Global: schema.Global
    Index: schema.Index
    Pointer: schema.Pointer
    Source: schema.Source
    Link: schema.Link
    Migration: schema.Migration
    Module: schema.Module
    ObjectType: schema.ObjectType
    Operator: schema.Operator
    OperatorKind: schema.OperatorKind
    Parameter: schema.Parameter
    ParameterKind: schema.ParameterKind
    Property: schema.Property
    PseudoType: schema.PseudoType
    Range: schema.Range
    ScalarType: schema.ScalarType
    SourceDeleteAction: schema.SourceDeleteAction
    TargetDeleteAction: schema.TargetDeleteAction
    Tuple: schema.Tuple
    TupleElement: schema.TupleElement
    TypeModifier: schema.TypeModifier
    Volatility: schema.Volatility
  }
  sys: {
    SystemObject: sys.SystemObject
    Database: sys.Database
    ExtensionPackage: sys.ExtensionPackage
    Role: sys.Role
    TransactionIsolation: sys.TransactionIsolation
    VersionStage: sys.VersionStage
  }
}

export namespace helper {
  type LinkType = std.BaseObject | std.BaseObject[]

  export type propertyKeys<T> = {
    [k in keyof T]: NonNullable<T[k]> extends LinkType ? never : k
  }[keyof T]

  export type linkKeys<T> = {
    [k in keyof T]: NonNullable<T[k]> extends LinkType ? k : never
  }[keyof T]

  export type Props<T> = Pick<T, propertyKeys<T>>
  export type Links<T> = Pick<T, linkKeys<T>>
}
